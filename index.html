<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>AR Shadow Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="importmap">{"imports": {"three": "https://unpkg.com/three@0.150.1/build/three.module.js"}}</script>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    #ui { position: absolute; top: 20px; left: 20px; z-index: 100; }
    button { padding: 15px 30px; font-size: 16px; background: #ff6b35; color: white; border: none; border-radius: 25px; cursor: pointer; }
    button:hover { background: #ff8c00; }
    #info { margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.8); color: white; border-radius: 10px; max-width: 300px; display: none; }
  </style>
</head>
<body>
  <div id="ui">
    <button id="start">Enter Shadow World</button>
    <div id="info"></div>
  </div>

  <script type="module">
    import * as THREE from 'three';

    let scene, camera, renderer, xrSession;
    let candle, character, wall, shadow;
    let controller, gameActive = false;
    let obstacles = [], enemies = [];

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);
      
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.setClearColor(0x000000, 0);
      document.body.appendChild(renderer.domElement);

      scene.add(new THREE.AmbientLight(0x404040, 0.3));
      
      document.getElementById('start').onclick = startAR;
    }

    async function startAR() {
      if (!navigator.xr) return alert('WebXR not supported');
      
      const supported = await navigator.xr.isSessionSupported('immersive-ar');
      if (!supported) return alert('AR not supported');
      
      xrSession = await navigator.xr.requestSession('immersive-ar', {
        requiredFeatures: ['hit-test'],
        optionalFeatures: ['dom-overlay'],
        domOverlay: { root: document.body }
      });
      
      renderer.xr.setSession(xrSession);
      document.getElementById('start').style.display = 'none';
      
      setupScene();
      setupController();
      
      renderer.setAnimationLoop(render);
      xrSession.addEventListener('end', () => {
        gameActive = false;
        document.getElementById('start').style.display = 'block';
        renderer.setAnimationLoop(null);
      });
    }

    function setupScene() {
      // Candle (closest to user)
      candle = new THREE.Group();
      
      // Candle body
      const body = new THREE.Mesh(
        new THREE.CylinderGeometry(0.015, 0.02, 0.12, 8),
        new THREE.MeshStandardMaterial({ color: 0xfff8dc })
      );
      body.position.y = 0.06;
      candle.add(body);
      
      // Flame
      const flame = new THREE.Mesh(
        new THREE.SphereGeometry(0.01, 6, 6),
        new THREE.MeshStandardMaterial({ 
          color: 0xff4500, 
          emissive: 0xff6600, 
          emissiveIntensity: 0.8 
        })
      );
      flame.position.y = 0.13;
      flame.scale.set(1, 1.5, 1);
      candle.add(flame);
      
      // Light
      const light = new THREE.PointLight(0xff6600, 1.5, 3);
      light.position.y = 0.13;
      candle.add(light);
      
      candle.position.set(0, -0.2, -0.4);
      scene.add(candle);

      // Character (middle)
      character = new THREE.Group();
      
      // Body
      const charBody = new THREE.Mesh(
        new THREE.CylinderGeometry(0.004, 0.004, 0.2, 6),
        new THREE.MeshStandardMaterial({ color: 0x333333 })
      );
      charBody.position.y = 0.1;
      character.add(charBody);
      
      // Head
      const head = new THREE.Mesh(
        new THREE.SphereGeometry(0.03, 8, 8),
        new THREE.MeshStandardMaterial({ color: 0x333333 })
      );
      head.position.y = 0.23;
      character.add(head);
      
      // Arms
      [-0.06, 0.06].forEach((x, i) => {
        const arm = new THREE.Mesh(
          new THREE.CylinderGeometry(0.002, 0.002, 0.1, 4),
          new THREE.MeshStandardMaterial({ color: 0x333333 })
        );
        arm.position.set(x, 0.15, 0);
        arm.rotation.z = i === 0 ? 0.3 : -0.3;
        character.add(arm);
      });
      
      character.position.set(0, -0.4, -0.8);
      scene.add(character);

      // Wall (background)
      wall = new THREE.Group();
      
      const wallMesh = new THREE.Mesh(
        new THREE.PlaneGeometry(2.5, 1.8),
        new THREE.MeshLambertMaterial({ 
          color: 0xf8f8f8, 
          transparent: true, 
          opacity: 0.95 
        })
      );
      wall.add(wallMesh);
      
      wall.position.set(0, 0, -1.5);
      scene.add(wall);

      // Shadow projection
      shadow = new THREE.Mesh(
        new THREE.PlaneGeometry(0.3, 0.3),
        new THREE.MeshBasicMaterial({ 
          color: 0x000000, 
          transparent: true, 
          opacity: 0.8 
        })
      );
      shadow.position.set(0, 0, -1.49);
      scene.add(shadow);

      createGameElements();
      gameActive = true;
      showInfo('Grab the candle! Move it closer/further to change shadow size');
    }

    function createGameElements() {
      // Obstacles
      [
        { x: -0.6, y: 0.2, w: 0.25, h: 0.15, type: 'block' },
        { x: 0.5, y: -0.3, w: 0.3, h: 0.2, type: 'block' },
        { x: 0, y: 0.4, w: 0.4, h: 0.12, type: 'gap' }
      ].forEach(obs => createObstacle(obs.x, obs.y, obs.w, obs.h, obs.type));

      // Enemies
      [
        { x: -0.4, y: 0.6, size: 0.08 },
        { x: 0.7, y: 0.1, size: 0.1 },
        { x: -0.2, y: -0.7, size: 0.06 }
      ].forEach(enemy => createEnemy(enemy.x, enemy.y, enemy.size));
    }

    function createObstacle(x, y, w, h, type) {
      const obs = new THREE.Group();
      
      if (type === 'block') {
        const block = new THREE.Mesh(
          new THREE.PlaneGeometry(w, h),
          new THREE.MeshBasicMaterial({ color: 0x8b4513, transparent: true, opacity: 0.8 })
        );
        obs.add(block);
      } else {
        // Gap - create frame
        const frame = 0.03;
        const frameMat = new THREE.MeshBasicMaterial({ color: 0x654321 });
        
        ['top', 'bottom', 'left', 'right'].forEach((side, i) => {
          const frameGeom = i < 2 ? 
            new THREE.PlaneGeometry(w + frame * 2, frame) :
            new THREE.PlaneGeometry(frame, h);
          const frameMesh = new THREE.Mesh(frameGeom, frameMat);
          
          if (side === 'top') frameMesh.position.y = h/2 + frame/2;
          else if (side === 'bottom') frameMesh.position.y = -h/2 - frame/2;
          else if (side === 'left') frameMesh.position.x = -w/2 - frame/2;
          else frameMesh.position.x = w/2 + frame/2;
          
          obs.add(frameMesh);
        });
      }
      
      obs.position.set(x, y, -1.48);
      obs.userData = { type, w, h };
      wall.add(obs);
      obstacles.push(obs);
    }

    function createEnemy(x, y, size) {
      const enemy = new THREE.Group();
      
      // Body
      const body = new THREE.Mesh(
        new THREE.SphereGeometry(size/2, 8, 8),
        new THREE.MeshBasicMaterial({ color: 0x4a0e4e, transparent: true, opacity: 0.9 })
      );
      enemy.add(body);
      
      // Legs
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const leg = new THREE.Mesh(
          new THREE.CylinderGeometry(0.001, 0.001, size * 0.8, 3),
          new THREE.MeshBasicMaterial({ color: 0x2d0833 })
        );
        leg.position.set(Math.cos(angle) * size/3, Math.sin(angle) * size/3, 0);
        leg.rotation.z = angle;
        enemy.add(leg);
      }
      
      enemy.position.set(x, y, -1.47);
      enemy.userData = { size, scared: false, originalX: x, originalY: y };
      wall.add(enemy);
      enemies.push(enemy);
    }

    function setupController() {
      controller = renderer.xr.getController(0);
      controller.addEventListener('selectstart', onGrab);
      controller.addEventListener('selectend', onRelease);
      scene.add(controller);
      
      const pointer = new THREE.Mesh(
        new THREE.SphereGeometry(0.008, 6, 6),
        new THREE.MeshStandardMaterial({ color: 0x00bfff, emissive: 0x0080ff, emissiveIntensity: 0.5 })
      );
      controller.add(pointer);
    }

    let grabbed = false;

    function onGrab(event) {
      const controllerPos = new THREE.Vector3();
      controller.getWorldPosition(controllerPos);
      
      const candlePos = new THREE.Vector3();
      candle.getWorldPosition(candlePos);
      
      if (controllerPos.distanceTo(candlePos) < 0.15) {
        grabbed = true;
        candle.children[1].material.emissiveIntensity = 1.2; // Brighten flame
        showInfo('Shadow size changes with candle distance!');
      }
    }

    function onRelease(event) {
      grabbed = false;
      if (candle.children[1]) {
        candle.children[1].material.emissiveIntensity = 0.8;
      }
    }

    function updateGame(time) {
      if (!gameActive) return;

      // Move candle with controller when grabbed
      if (grabbed && controller) {
        const controllerPos = new THREE.Vector3();
        controller.getWorldPosition(controllerPos);
        candle.position.copy(controllerPos);
        
        // Keep candle in reasonable range
        const charPos = new THREE.Vector3();
        character.getWorldPosition(charPos);
        const dist = candle.position.distanceTo(charPos);
        
        if (dist < 0.2) {
          const dir = new THREE.Vector3().subVectors(candle.position, charPos).normalize();
          candle.position.copy(charPos).add(dir.multiplyScalar(0.2));
        } else if (dist > 1.5) {
          const dir = new THREE.Vector3().subVectors(candle.position, charPos).normalize();
          candle.position.copy(charPos).add(dir.multiplyScalar(1.5));
        }
      }

      // Update shadow size based on candle-character distance
      const candlePos = new THREE.Vector3();
      const charPos = new THREE.Vector3();
      candle.getWorldPosition(candlePos);
      character.getWorldPosition(charPos);
      
      const distance = candlePos.distanceTo(charPos);
      const shadowSize = Math.max(0.2, Math.min(1.2, 2 / distance));
      shadow.scale.set(shadowSize, shadowSize, 1);
      
      // Position shadow on wall
      shadow.position.x = charPos.x;
      shadow.position.y = charPos.y;

      // Make wall face camera
      wall.lookAt(camera.position);

      // Animate flame
      if (candle.children[1]) {
        candle.children[1].scale.y = 1.5 + Math.sin(time * 0.008) * 0.2;
        candle.children[1].rotation.z = Math.sin(time * 0.006) * 0.1;
      }

      // Check shadow interactions
      checkCollisions(shadowSize);

      // Animate enemies
      enemies.forEach((enemy, i) => {
        enemy.rotation.z += 0.01;
        if (!enemy.userData.scared) {
          enemy.position.y += Math.sin(time * 0.003 + i) * 0.001;
        }
      });
    }

    function checkCollisions(shadowSize) {
      const shadowPos = shadow.position;
      
      // Check obstacles
      obstacles.forEach(obs => {
        const obsPos = obs.position;
        const { w, h, type } = obs.userData;
        
        if (type === 'block') {
          if (Math.abs(shadowPos.x - obsPos.x) < (w/2 + shadowSize/2) &&
              Math.abs(shadowPos.y - obsPos.y) < (h/2 + shadowSize/2)) {
            // Hit obstacle
            obs.children[0].material.color.setHex(0xff0000);
            setTimeout(() => obs.children[0].material.color.setHex(0x8b4513), 200);
          }
        } else if (type === 'gap') {
          if (Math.abs(shadowPos.x - obsPos.x) < w/2 && Math.abs(shadowPos.y - obsPos.y) < h/2) {
            if (shadowSize > Math.min(w, h) * 0.9) {
              showInfo('Shadow too big for gap!');
            } else {
              showInfo('Nice! Shadow fits through gap!');
            }
          }
        }
      });

      // Check enemies
      enemies.forEach(enemy => {
        const enemyPos = enemy.position;
        const dist = shadowPos.distanceTo(enemyPos);
        
        if (shadowSize > enemy.userData.size * 4 && dist < 0.3) {
          // Big shadow scares enemy
          if (!enemy.userData.scared) {
            enemy.userData.scared = true;
            const dir = new THREE.Vector3().subVectors(enemyPos, shadowPos).normalize();
            enemy.position.add(dir.multiplyScalar(0.2));
            enemy.children[0].material.color.setHex(0x808080);
            showInfo('Enemy scared away!');
          }
        } else if (dist > 0.5 && enemy.userData.scared) {
          // Reset enemy
          enemy.userData.scared = false;
          enemy.position.x = enemy.userData.originalX;
          enemy.position.y = enemy.userData.originalY;
          enemy.children[0].material.color.setHex(0x4a0e4e);
        }
      });
    }

    function showInfo(text) {
      const info = document.getElementById('info');
      info.textContent = text;
      info.style.display = 'block';
      setTimeout(() => info.style.display = 'none', 3000);
    }

    function render(timestamp, frame) {
      updateGame(timestamp);
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    init();
  </script>
</body>
</html>
